
#include <bgpparser.h>
#include <visitors/GJVoidDepthFirst.h>

#include "ASSegmentVisitor.h"

#include "Params.h"

class AttrsVisitor : public GJVoidDepthFirst
{
	ASSegmentVisitor _asSegmentVisitor;

	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////// ORIGIN //////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeOrigin &n, boost::any &param )
	{
//		n.getLength( )
//		n.getData( )
//		n.getAS4( )

		switch( n.getOrigin( ) )
		{
		case IGP:
			param.origin="IGP";
			break;
		case EGP:
			param.origin="EGP";
			break;
		default:
			param.origin="INCOMPLETE";
			break;
		}
	}

	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////// AS PATH /////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual boost::any& visit( AttributeTypeASPath &n, boost::any &param )
	{
		ostringstream os;

		bool isFirst=true;
		BOOST_FOREACH( const AttributeTypeASPathSegmentPtr &segment, /**/n.getPathSegmentsComplete()/**/ )
		{
			if( isFirst )
				isFirst=false;
			else
				os << " ";

			os << segment->accept( _asSegmentVisitor, os );
		}

		param.as_path=os.str( );
	}

	virtual boost::any& visit( AttributeTypeAS4Path &n, boost::any &param )
	{
		ostringstream os;

		bool isFirst=true;
		BOOST_FOREACH( const AttributeTypeASPathSegmentPtr &segment, /**/n.getPathSegments()/**/ )
		{
			if( isFirst )
				isFirst=false;
			else
				os << " ";

			os << segment->accept( _asSegmentVisitor, os );
		}

		param.as_path=os.str( );
	}

	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////// NEXT HOP ////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeNextHop &n, boost::any &param )
	{
		param.nexthop=FORMAT_IP_ADDRESS( n.getNextHopIPAddress(), n.getNextHopAFI() );
	}

	//////////////////////////////////////////////////////////////////////////////
	////////////////////////////// MultiExitDisc /////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeMultiExitDisc &n, boost::any &param )
	{
		param.med=n.getMultiExitDiscValue( );
	}

	//////////////////////////////////////////////////////////////////////////////
	////////////////////////////// LOCAL PREF ////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeLocalPref &n, boost::any &param )
	{
		param.lpref=n.getLocalPrefValue( );
	}

	//////////////////////////////////////////////////////////////////////////////
	/////////////////////////// ATOMIC AGGREGATE ////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeAtomicAggregate &n, boost::any &param )
	{
		param.agg="AG";
	}

	//////////////////////////////////////////////////////////////////////////////
	////////////////////////////// AGGREGATOR ////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual boost::any& visit( AttributeTypeAggregator &n, boost::any &param )
	{
		ostringstream os;
		os << (int)n.getAggregatorLastASComplete( ) << " "
		   << FORMAT_IPv4_ADDRESS( n.getAggregatorBGPSpeakerIPAddress().ipv4 );

		param.aggregator=os.str( );
	}

	//////////////////////////////////////////////////////////////////////////////
	////////////////////////////// COMMUNITIES ///////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	virtual void visit( AttributeTypeCommunities &n, boost::any &param )
	{
	    ostringstream node;
	    string sep  = "";

	    BOOST_FOREACH( const CommunityValue &value, n.getCommunityValue() )
	    {
	        if( value.ASnum == 0xFFFF && value.info == 0xFF01 )
	        {
	            node << sep << "no-export";
	        }
	        else
	        {
	        	node << sep << (int)value.ASnum << ":" << (int)value.info;
	        }
	        sep = " ";
	    }
	    return node.str();
	}
};
